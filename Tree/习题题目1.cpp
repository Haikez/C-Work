//先中后遍历序列:
// 1 2 4 7 10 3 5 8 9 6
// 4 7 2 10 1 8 5 9 3 6
// 7 4 10 2 8 9 5 6 3 1

// 1. 求二叉链表树的树高
// 2. 根据先序和中序构造二叉链表树
// 3.判断是否为完全二叉树
// 4.将指针p指向二叉树中值为key的结点
// 5. 输出先序遍历中第k个值
// 6. 求树的宽度
// 7.计算一棵给定二叉树的所有双分支结点个数
// 8.把树中所有结点的左右子树进行交换
// 9.删除树中所有值为x的结点，删去以它为根的子树，并释放空间
// 10.打印值为x的结点的所有祖先，假设值为x的结点不多于1个
// 11.设一棵二叉树的结点结构为(LLINK,INFO,RLINK),ROOT为指向该二叉树根节点的指针，p和q分别为指向该二叉树中任意两个结点的指针，试编写算法ANCESTOR(ROOT,p,q,r),找到p和q的最近公共祖先结点r
// 12.有一棵满二叉树，已知先序，设计一个算法求其后序
// 13.设计一个非递归方法求二叉树高度
// 14.设计算法，将二叉树叶子结点从左往右穿起来
// 15 判断两个二叉树是否相似
//16. 设计算法输出二叉树中值为x的层号
//17.计算二叉树叶子结点的权值和
//18. 将给定的表达式转化成中缀表达式（用括号反映操作次序）